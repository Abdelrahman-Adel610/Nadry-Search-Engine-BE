package indexer;

import com.mongodb.client.MongoDatabase;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.security.MessageDigest;
import java.util.LinkedList;
import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

public class Main {
    public static void main(String[] args) {
        ExecutorService executor = Executors.newFixedThreadPool(4);
        InvertedIndex index = null;
        MongoDBIndexStore mongoStore = null;

        try {
            // Define document paths and URLs
            Path filePath = Paths.get("src/main/java/test.html");
            Path filePath2 = Paths.get("src/main/java/sample1.html");
            Path filePath3 = Paths.get("src/main/java/sample2.html");
            String url1 = "https://example.com/test.html";
            String url2 = "https://example.com/sample1.html";
            String url3 = "https://example.com/sample2.html";

            // Validate file existence
            if (!Files.exists(filePath) || !Files.exists(filePath2) || !Files.exists(filePath3)) {
                throw new RuntimeException("One or more files do not exist");
            }

            List<Path> paths = new LinkedList<>();
            List<String> links = new LinkedList<>();
            paths.add(filePath);
            paths.add(filePath2);
            paths.add(filePath3);
            links.add(url1);
            links.add(url2);
            links.add(url3);

            // Compute docIds for debugging and testing
            String[] docIds = new String[3];
            docIds[0] = "7f8e911cc1c69b266417bc92e7e3fddf048aac7ef16e132632bc5c2404440fbf"
            docIds[1] = computeSha256(filePath2.toString());
            docIds[2] = computeSha256(filePath3.toString());

            // MongoDB configuration
            String mongoConnectionString = System.getenv("MONGO_URI") != null
                ? System.getenv("MONGO_URI")
                : "mongodb://localhost:27017/search_engine";
            String databaseName = "search_engine";
            String collectionName = "inverted_index";

            // Initialize components
            DocumentProcessor processor = new DocumentProcessor();
            StopWordFilter stopWordFilter = new StopWordFilter();
            Tokenizer tokenizer = new Tokenizer(stopWordFilter);
            mongoStore = new MongoDBIndexStore(mongoConnectionString, databaseName, collectionName);

            // Clear collections
            MongoDatabase database = mongoStore.getDatabase();
            database.getCollection("inverted_index").drop();
            database.getCollection("Documents").drop();
            System.out.println("Cleared inverted_index and Documents collections");

            // Print input
            System.out.println("URLs:");
            for (String link : links) {
                System.out.println(link);
            }
            System.out.println("--------------------------------------");
            System.out.println("Document Paths and DocIDs:");
            for (int i = 0; i < paths.size(); i++) {
                System.out.println(paths.get(i).toString() + " -> " + docIds[i]);
            }
            System.out.println("--------------------------------------");

            // Submit index building task
            System.out.println("Starting index building...");
            IndexBuilder indexBuilder = new IndexBuilder(
                processor,
                tokenizer,
                mongoConnectionString,
                databaseName,
                collectionName
            );
            index = getIndex(indexBuilder);
            CompletableFuture<Void> indexBuildingFuture = CompletableFuture.runAsync(() -> {
                try {
                    indexBuilder.buildIndex(paths, links);
                    System.out.println("Index building completed.");
                } catch (Exception e) {
                    System.err.println("Error during index building: " + e.getMessage());
                    e.printStackTrace();
                    throw new RuntimeException("Index building failed", e);
                }
            }, executor);

            // Wait for index building
            indexBuildingFuture.join();

            // Test document retrieval
            System.out.println("Testing document retrieval...");
            for (String docId : docIds) {
                DocumentData doc = mongoStore.getDocument(docId);
                if (doc == null) {
                    System.out.println("ERROR: Document '" + docId + "' not found in Documents collection");
                } else {
                    System.out.println("Document '" + docId + "' found:");
                    System.out.println("  URL: " + doc.getUrl());
                    System.out.println("  Title: " + doc.getTitle());
                    System.out.println("  Description: " + doc.getDescription());
                    System.out.println("  Content: " + doc.getContent());
                    System.out.println("  Links: " + doc.getLinks());
                    System.out.println("  Total Words: " + doc.getTotalWords());
                }
            }
            System.out.println("Document retrieval testing completed.");

        } catch (Exception e) {
            System.err.println("Error in main: " + e.getMessage());
            e.printStackTrace();
        } finally {
            // Close resources
            if (index != null) {
                try {
                    index.close();
                } catch (Exception e) {
                    System.err.println("Error closing index: " + e.getMessage());
                    e.printStackTrace();
                }
            }
            if (mongoStore != null) {
                try {
                    mongoStore.close();
                } catch (Exception e) {
                    System.err.println("Error closing MongoDB store: " + e.getMessage());
                    e.printStackTrace();
                }
            }
            try {
                executor.shutdown();
                if (!executor.awaitTermination(60, TimeUnit.SECONDS)) {
                    executor.shutdownNow();
                    System.err.println("Executor did not terminate within timeout");
                }
            } catch (InterruptedException e) {
                executor.shutdownNow();
                Thread.currentThread().interrupt();
                System.err.println("Executor shutdown interrupted: " + e.getMessage());
            }
        }
    }

    private static InvertedIndex getIndex(IndexBuilder builder) throws Exception {
        java.lang.reflect.Field indexField = IndexBuilder.class.getDeclaredField("index");
        indexField.setAccessible(true);
        return (InvertedIndex) indexField.get(builder);
    }

    private static String computeSha256(String input) {
        try {
            MessageDigest digest = MessageDigest.getInstance("SHA-256");
            byte[] hash = digest.digest(input.getBytes("UTF-8"));
            StringBuilder hexString = new StringBuilder();
            for (byte b : hash) {
                String hex = Integer.toHexString(0xff & b);
                if (hex.length() == 1) hexString.append('0');
                hexString.append(hex);
            }
            return hexString.toString();
        } catch (Exception e) {
            throw new RuntimeException("Error computing SHA-256", e);
        }
    }
}